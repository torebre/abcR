library(geoR)

kFigFolder <- "variogram_bins"

# Seeing how the distances to the observed sample look when 
# using a distance measure that compares the distances between 
# the mean values in the variogram bins between the observed 
# sample and the ABC-samples


# Transforms a sample realisation to a list containing the coordinates 
# and the values at the points given by the coordinates. This is done 
# to provide input to the function that computes the variogram
TransformSampleToFormatForVariogramFunction <- function(my.sample) {
  my.sample.dims <- dim(my.sample)
  my.sample.coords <- matrix(NA, my.sample.dims[1] * my.sample.dims[2], 2)
  my.sample.all.observations <- rep(NA, my.sample.dims[1] * my.sample.dims[2])
  
  counter <- 1
  
  for(i in 1:my.sample.dims[1]) {
    for(j in 1:my.sample.dims[2]) {
      # current.row <- (i - 1) * my.sample.dims[1] + j
      current.row <- counter
      counter <- counter + 1
      my.sample.coords[current.row, 1] <- i
      my.sample.coords[current.row, 2] <- j
      my.sample.all.observations[current.row] <- my.sample[i, j]
    }
  }
  list(sample.coords = my.sample.coords, sample.all.observations = my.sample.all.observations)
}


# Variogram for observed sample
actual.data.input.to.variogram.function <- TransformSampleToFormatForVariogramFunction(actual.structure)
actual.data.empirical.variogram.all.points <- variog(coord = actual.data.input.to.variogram.function$sample.coords, 
                                                     data = actual.data.input.to.variogram.function$sample.all.observations)

# Distances
# actual.data.empirical.variogram.all.points$u
# Estimated variogram values
# actual.data.empirical.variogram.all.points$v
# Points in each bin
# actual.data.empirical.variogram.all.points$n

# Use the same bin ranges when computing the variograms for the samples
bins.limits <- actual.data.empirical.variogram.all.points$bins.lim

actual.data.empirical.variomodel.all.points <- variofit(actual.data.empirical.variogram.all.points, cov.model = "exponential")
actual.data.empirical.variomodel.all.points$cov.pars


plot(actual.data.empirical.variogram.all.points)
lines.variomodel(cov.model = "exponential", cov.pars=c(kVariance, kPhi), nugget = 0, col = "blue")
lines.variomodel(cov.model = "exponential", cov.pars = actual.data.empirical.variomodel.all.points$cov.pars, nugget = 0, col = "red")


# Compute variogram for all samples generated by ABC
number.of.samples.to.include <- length(abc.samples)
abc.variogram.fit.estimates.all.points <- matrix(NA, nrow = number.of.samples.to.include, ncol = length(bins.limits) - 1)
for(i in 1:number.of.samples.to.include) {
  print(paste("Looking at sample ", i))
  transformed.sample <- TransformSampleToFormatForVariogramFunction(abc.samples[[i]]$abc.prior)
  my.empirical.variogram <- variog(coord = transformed.sample$sample.coords, data = transformed.sample$sample.all.observations, breaks = bins.limits)
  abc.variogram.fit.estimates.all.points[i, ] <- my.empirical.variogram$v
}

plot(abc.variogram.fit.estimates.all.points[ , 1], abc.variogram.fit.estimates.all.points[ , 2], pch = 19, cex = 0.3)
plot(abc.variogram.fit.estimates.all.points[ , 1], pch = 19, cex = 0.3)

# Compute the distances to the sample representing the truth
abc.distance.variogram.parameters.all.points <- matrix(NA, nrow = length(abc.samples), ncol = 5)
for(i in 1:length(abc.samples)) {
  distance <- sum((actual.data.empirical.variogram.all.points$v - abc.variogram.fit.estimates.all.points[i, ])^2)
  abc.distance.variogram.parameters.all.points[i , ] = c(distance, abc.samples[[i]]$prior.phi, abc.samples[[i]]$prior.mean, abc.samples[[i]]$prior.variance, abc.samples[[i]]$prior.obs.noise)
}

# Sort by distance
indices.ordered.by.variogram.distance <- order(abc.distance.variogram.parameters.all.points[, 1])
variogram.distance.ordered.parameter.matrix <- abc.distance.variogram.parameters.all.points[indices.ordered.by.variogram.distance, ]


png(paste("../../abcR_doc/fig/", kFigFolder, "/variogram_bin_values_plotted_50_samples.png", sep =""))
plot(actual.data.empirical.variogram.all.points$v, type = "l", col = "red", ylim = c(0, 4), ann = F)
for(i in 1:50) {
  points(abc.variogram.fit.estimates.all.points[indices.ordered.by.variogram.distance[i], ], type = "l", col = "blue")
}
points(actual.data.empirical.variogram.all.points$v, type = "l", col = "red", ylim = c(0, 5), lwd = 2)
# title("Variogram bins interpolated")
dev.off()

png(paste("../../abcR_doc/fig/", kFigFolder, "/k_distance_all_samples.png", sep =""))
plot(variogram.distance.ordered.parameter.matrix[, 1], type = "l", ann = F)
title(latex2exp("Distance to $\\hat{\\theta}$ for all samples"), sub = latex2exp("Distance measure: $(\\hat{\\sigma}^{2} - \\sigma_{k}^{2})^2 + (\\hat{\\phi} - \\phi_{k})^2$"))
dev.off()

# Remove some of the points with very large distances from the plot
png(paste("../../abcR_doc/fig/", kFigFolder, "/k_distance_100_best_samples.png", sep =""))
plot(variogram.distance.ordered.parameter.matrix[1:100, 1], type = "l")
title(latex2exp("Distance to $\\hat{\\theta}$ for 100 best samples"))
dev.off()

png(paste("../../abcR_doc/fig/", kFigFolder, "/contour_all_points_superimposed.png", sep =""))
filled.contour(phi.points, variance.points, post.prob.eval.points.matrix, 
               plot.axes = {axis(1); axis(2); points(variogram.distance.ordered.parameter.matrix[ , 2], variogram.distance.ordered.parameter.matrix[ , 4], col = 'black', pch = 19, cex = 0.3)})
title(latex2exp('Likelihood $p(x | \\theta)$ with all samples superimposed'), xlab = latex2exp('$\\phi$'), ylab = latex2exp('$\\sigma^{2}$'))
dev.off()

# Since the prior samples only come from a small area 
# of the total area shown in the likelihood plot, cut 
# out a part of the plot and add the points to it 
# so that they are more visible
post.prob.matrix.dim <- dim(post.prob.eval.points.matrix)
likelihood.cut.out <- post.prob.eval.points.matrix[2:9, 1:6]
filled.contour(likelihood.cut.out)
image(likelihood.cut.out)
phi.points.cut.out <- phi.points[2:9]
variance.points.cut.out <- variance.points[1:6]

png(paste("../../abcR_doc/fig/", kFigFolder, "/contour_all_points_superimposed_cut_out.png", sep =""))
filled.contour(phi.points.cut.out, variance.points.cut.out, likelihood.cut.out, 
               plot.axes = {axis(1); axis(2); points(variogram.distance.ordered.parameter.matrix[ , 2], variogram.distance.ordered.parameter.matrix[ , 4], col = 'black', pch = 19, cex = 0.3)})
dev.off()

png(paste("../../abcR_doc/fig/", kFigFolder, "/contour_50_points_superimposed_cut_out.png", sep =""))
filled.contour(phi.points.cut.out, variance.points.cut.out, likelihood.cut.out, 
               plot.axes = {axis(1); axis(2); points(variogram.distance.ordered.parameter.matrix[1:50, 2], variogram.distance.ordered.parameter.matrix[1:50, 4], col = 'black', pch = 19, cex = 0.3)})
title(latex2exp('Likelihood $p(x | \\theta)$, variogram estimates superimposed'), xlab = latex2exp('$\\phi$'), ylab = latex2exp('$\\sigma^{2}$'))
dev.off()

# Find the optimal number of samples to include
actual.structure.dims <- dim(actual.structure)
cumulative.mean.estimates <- matrix(0, length(abc.samples), actual.structure.dims[1] * actual.structure.dims[2])
mspe.k <- rep(NA, length(abc.samples))

for(i in 1:length(abc.samples)) {
  kth.sample <- as.vector(abc.samples[[indices.ordered.by.variogram.distance[i]]]$abc.prior)
  
  if(i > 1) {
    prev.sum <- (i - 1) * cumulative.mean.estimates[i - 1]
  }
  else {
    prev.sum <- 0
  }
  cumulative.mean.estimates[i, ] <- (prev.sum + kth.sample) / i
  mspe.k[i] <- sum((actual.structure - cumulative.mean.estimates[i , ])^2)
}


png(paste("../../abcR_doc/fig/", kFigFolder, "/mspe_all_points.png", sep =""))
plot(mspe.k, type = "l", xlab = "k", ylab = "MSPE")
title("MSPE all samples")
dev.off()

png(paste("../../abcR_doc/fig/", kFigFolder, "/mspe_50_closest_points.png", sep =""))
plot(mspe.k[1:50], type = "l")
title("MSPE 50 closest points")
dev.off()


optimal.k <- which.min(mspe.k)

png(paste("../../abcR_doc/fig/", kFigFolder, "/contour_optimal_k_cut_out.png", sep =""))
filled.contour(phi.points.cut.out, variance.points.cut.out, likelihood.cut.out,
               plot.axes = {axis(1); 
                 axis(2); 
                 points(variogram.distance.ordered.parameter.matrix[1:optimal.k , 2], variogram.distance.ordered.parameter.matrix[1:optimal.k , 4], col = 'black', pch = 19, cex = 0.3);
                 points(actual.data.empirical.variomodel.all.points$cov.pars[2], actual.data.empirical.variomodel.all.points$cov.pars[1], col = 'red', pch = 19, cex = 1);
                 points(kPhi, kVariance, col = 'green', pch = 19, cex = 1)})
dev.off()


# best.indices <- indices.ordered.by.variogram.distance[1:optimal.k]
optimal.sample <- matrix(0, grid.length, grid.length)
for(i in 1:optimal.k) {
  optimal.sample <- optimal.sample + abc.samples[[indices.ordered.by.variogram.distance[i]]]$abc.prior
}
optimal.sample <- optimal.sample / optimal.k

filled.contour(optimal.sample)
filled.contour(actual.structure)

filled.contour(abs(optimal.sample - actual.structure))


filled.contour(abs(optimal.sample - abc.samples[[indices.ordered.by.variogram.distance[1]]]$abc.prior))

png(paste("../../abcR_doc/fig/", kFigFolder, "/contour_optimal_k.png", sep =""))
filled.contour(phi.points, variance.points, post.prob.eval.points.matrix, 
               plot.axes = {axis(1); 
                 axis(2); 
                 points(variogram.distance.ordered.parameter.matrix[1:optimal.k , 2], variogram.distance.ordered.parameter.matrix[1:optimal.k , 4], col = 'black', pch = 19, cex = 0.3);
                 points(actual.data.empirical.variomodel.all.points$cov.pars[2], actual.data.empirical.variomodel.all.points$cov.pars[1], col = 'red', pch = 19, cex = 1);
                 points(kPhi, kVariance, col = 'green', pch = 19, cex = 1);})
title(paste("Optimal number of points", optimal.k), sub ="Red dot is variogram estimate based on truth. Green dot is true values")
dev.off()


# title(latex2exp('Likelihood $p(\\theta | x)$'), xlab = latex2exp('$\\phi$'), ylab = latex2exp('$\\sigma^{2}$'))


levelplot(phi.points, variance.points, post.prob.eval.points.matrix)
filled.contour(phi.points, variance.points, post.prob.eval.points.matrix, 
               plot.axes = points(actual.data.empirical.variomodel.all.points$cov.pars[2], actual.data.empirical.variomodel.all.points$cov.pars[1], col = 'red', pch = 19, cex = 0.3))

points(actual.data.empirical.variomodel.all.points$cov.pars[2], actual.data.empirical.variomodel.all.points$cov.pars[1], col = 'green', pch = 19, cex = 2)

contourplot(x = post.prob.eval.points.matrix)

points(kPhi, kVariance, col = 'yellow', pch = 19, cex = 2)


title(latex2exp('Likelihood $p(\\theta | x)$'), xlab = latex2exp('$\\phi$'), ylab = latex2exp('$\\sigma^{2}$'))


plot(variogram.distance.ordered.parameter.matrix[ , 1], type = "p", cex = 0.3)


# input.for.density.estimate <- cbind(variogram.distance.ordered.parameter.matrix[1:optimal.k , 2], variogram.distance.ordered.parameter.matrix[1:optimal.k , 1])
# density.data <- density(input.for.density.estimate)
# plot(density.data)

density.data <- kde2d(variogram.distance.ordered.parameter.matrix[1:optimal.k , 2], variogram.distance.ordered.parameter.matrix[1:optimal.k , 4])
# plot(density.data)
# image(density.data)

png(paste("../../abcR_doc/fig/", kFigFolder, "/density_plot_theta.png", sep =""))
filled.contour(density.data)
title(latex2exp("Density plot for $\\hat{\\theta}$ given optimal k"))
dev.off()