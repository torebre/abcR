library(geoR)


# Transforms a sample realisation to a list containing the coordinates 
# and the values at the points given by the coordinates. This is done 
# to provide input to the function that computes the variogram
TransformSampleToFormatForVariogramFunction <- function(my.sample) {
  my.sample.dims <- dim(my.sample)
  my.sample.coords <- matrix(NA, my.sample.dims[1] * my.sample.dims[2], 2)
  my.sample.all.observations <- rep(NA, my.sample.dims[1] * my.sample.dims[2])
  
  for(i in 1:my.sample.dims[1]) {
    for(j in 1:my.sample.dims[2]) {
      current.row <- (i - 1) * my.sample.dims[1] + j
      my.sample.coords[current.row, 1] <- i
      my.sample.coords[current.row, 2] <- j
      my.sample.all.observations[current.row] <- my.sample[i, j]
    }
  }
  list(sample.coords = my.sample.coords, sample.all.observations = my.sample.all.observations)
}


# Compute variogram for the sample representing the truth

# Use all points in realisation when computing variogram
actual.data.input.to.variogram.function <- TransformSampleToFormatForVariogramFunction(actual.structure)
actual.data.empirical.variogram.all.points <- variog(coord = actual.data.input.to.variogram.function$sample.coords, 
                                                     data = actual.data.input.to.variogram.function$sample.all.observations)
actual.data.empirical.variomodel.all.points <- variofit(actual.data.empirical.variogram.all.points, cov.model = "exponential")
actual.data.empirical.variomodel.all.points$cov.pars

plot(actual.data.empirical.variogram.all.points)
lines.variomodel(cov.model = "exponential", cov.pars=c(kVariance, kPhi), nugget = 0, col = "blue")
lines.variomodel(cov.model = "exponential", cov.pars = actual.data.empirical.variomodel.all.points$cov.pars, nugget = 0, col = "red")

# Compute variogram for all samples generated by ABC
abc.variogram.fit.estimates.all.points = matrix(NA, nrow = length(abc.samples), ncol = 2)
for(i in 1:length(abc.samples)) {
  print(paste("Looking at sample ", i))
  transformed.sample <- TransformSampleToFormatForVariogramFunction(abc.samples[[i]]$abc.prior)
  my.empirical.variogram <- variog(coord = transformed.sample$sample.coords, data = transformed.sample$sample.all.observations)
  my.empirical.variomodel <- variofit(my.empirical.variogram, ini.cov.pars = c(abc.samples[[i]]$prior.variance, abc.samples[[i]]$prior.phi), cov.model = "exponential")
  abc.variogram.fit.estimates.all.points[i, 1] <- my.empirical.variomodel$cov.pars[1]
  abc.variogram.fit.estimates.all.points[i, 2] <- my.empirical.variomodel$cov.pars[2]
}

# Plot the estimates for the correlation function parameters for the 
# different samples
plot(abc.variogram.fit.estimates.all.points[ , 1], abc.variogram.fit.estimates.all.points[ , 2])

# Distance function used to order the distance of the samples 
# to the actual data
GetDifferenceInVariogramEstimates <- function(my.phi, my.variance) {
  (abs(actual.data.empirical.variomodel.all.points$cov.pars[1] - my.variance))^2 + (abs(actual.data.empirical.variomodel.all.points$cov.pars[2] - my.phi))^2
}

abc.distance.variogram.parameters.all.points <- matrix(NA, nrow = length(abc.samples), ncol = 5)
for(i in 1:length(abc.samples)) {
  distance <- GetDifferenceInVariogramEstimates(abc.variogram.fit.estimates.all.points[i, 2], abc.variogram.fit.estimates.all.points[i, 1])
  # print(paste("Distance:", distance))
  abc.distance.variogram.parameters.all.points[i , ] = c(distance, abc.samples[[i]]$prior.phi, abc.samples[[i]]$prior.mean, abc.samples[[i]]$prior.variance, abc.samples[[i]]$prior.obs.noise)
}

indices.ordered.by.variogram.distance <- order(abc.distance.variogram.parameters.all.points[, 1])
variogram.distance.ordered.parameter.matrix <- abc.distance.variogram.parameters.all.points[indices.ordered.by.variogram.distance, ]

plot(variogram.distance.ordered.parameter.matrix[, 1], type = "l")
# Remove some of the points with very large distances from the plot
plot(variogram.distance.ordered.parameter.matrix[1:(length(abc.samples) - 200), 1], type = "l")



filled.contour(phi.points, variance.points, post.prob.eval.points.matrix, 
               plot.axes = points(variogram.distance.ordered.parameter.matrix[ , 2], variogram.distance.ordered.parameter.matrix[ , 4], col = 'black', pch = 19, cex = 0.3))
title(latex2exp('Likelihood $p(\\theta | x)$'), xlab = latex2exp('$\\phi$'), ylab = latex2exp('$\\sigma^{2}$'))


actual.structure.dims <- dim(actual.structure)
cumulative.mean.estimates <- matrix(0, length(abc.samples), actual.structure.dims[1] * actual.structure.dims[2])
mspe.k <- rep(NA, length(abc.samples))

for(i in 1:length(abc.samples)) {
  kth.sample <- as.vector(abc.samples[[indices.ordered.by.variogram.distance[i]]]$abc.prior)
  
  if(i > 1) {
    prev.sum <- (i - 1) * cumulative.mean.estimates[i - 1]
  }
  else {
    prev.sum <- 0
  }
  cumulative.mean.estimates[i, ] <- (prev.sum + kth.sample) / i
  mspe.k[i] <- sum((actual.structure - cumulative.mean.estimates[i , ])^2)
}


plot(mspe.k, type = "l", xlab = "k", ylab = "MSPE")

plot(mspe.k[1:50], type = "l")


optimal.k <- which.min(mspe.k)

filled.contour(phi.points, variance.points, post.prob.eval.points.matrix, 
               plot.axes = points(variogram.distance.ordered.parameter.matrix[1:optimal.k , 2], variogram.distance.ordered.parameter.matrix[1:optimal.k , 4], col = 'black', pch = 19, cex = 0.3))
title(latex2exp('Likelihood $p(\\theta | x)$'), xlab = latex2exp('$\\phi$'), ylab = latex2exp('$\\sigma^{2}$'))



filled.contour(phi.points, variance.points, post.prob.eval.points.matrix, 
               plot.axes = points(actual.data.empirical.variomodel.all.points$cov.pars[2], actual.data.empirical.variomodel.all.points$cov.pars[1], col = 'red', pch = 19, cex = 0.3))

title(latex2exp('Likelihood $p(\\theta | x)$'), xlab = latex2exp('$\\phi$'), ylab = latex2exp('$\\sigma^{2}$'))



plot(variogram.distance.ordered.parameter.matrix[ , 1], type = "p", cex = 0.3)


